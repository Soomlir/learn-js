# Функции
- `Function Declaration` - Это значит, что код с ними можно вызывать до их объявления.
- `Function Expression` - Не поднимаются (не hoisting). Вы можете вызывать такие функции только после их объявления, иначе получите ошибку.
- `Arrow Functions` - Нет собственного контекста `this`. Внутри стрелочных функций this будет указывать на контекст, в котором эта функция была определена.

Верхняя область видимости — это область видимости на глобальном уровне, которая зависит от контекста выполнения (например, браузер или Node.js). В классическом подходе с подключением файлов она относится к глобальному пространству, а в случае модульной системы каждый файл имеет свою собственную область видимости, изолированную от других.

## Function Declaration
```js
function getName() {
  // тело функции
}
```
1. Объявление функции:
- Функция, объявленная с использованием ключевого слова `function`, доступна для вызова до ее фактической строки в коде благодаря механизму `hoisting (подъем)`.
- Пример:
```js
console.log(getName()); // Работает, даже если вызов до определения функции
function getName() {
  return 'John';
}
```
Это связано с тем, что JavaScript "поднимает" (hoists) объявление функции в верхнюю часть области видимости (но не её тело).

2. Сильная привязка к области видимости:
- Функции могут быть `локальными` (если определены внутри другой функции) или `глобальными` (если находятся на верхнем уровне).
- Например, если функция определена внутри другого блока, она будет доступна только в этом блоке.

3. Аргументы функции:
- Аргументы можно передавать в функцию через скобки ().
- Внутри функции также доступен объект arguments, который представляет собой массивоподобный объект, содержащий все переданные аргументы (для обычных функций).
Пример с использованием arguments:
```js
function sum() {
  let total = 0;
  for (let i = 0; i < arguments.length; i++) {
    total += arguments[i];
  }
  return total;
}

console.log(sum(1, 2, 3)); // 6
```
4. Значение this:
- В обычной функции контекст `this` зависит от того, как она была вызвана. Если функция вызвана в глобальной области видимости (не как метод объекта), то `this` будет ссылаться на глобальный объект (в браузере это `window`, в строгом режиме — `undefined`).
```js
function showThis() {
  console.log(this); // в глобальном контексте это будет window (в браузере)
}
showThis();
```
5. Return:
- Если в теле функции нет явного оператора `return`, она возвращает `undefined` по умолчанию.
- Функции могут возвращать значения, которые затем могут быть использованы.

6. Функции как объекты:
- Функции в JavaScript — это объекты, поэтому их можно передавать в другие функции как аргументы, возвращать из других функций или присваивать переменным.


## Function Expression
1. Анонимная функция (переменная)
```js
const func = function () { }
```
- В этом случае создается анонимная функция, которая не имеет имени.
- Функция присваивается переменной func.
- Имя функции не доступно внутри самой функции (она анонимна), а само имя func существует только как имя переменной, к которой присваивается эта функция.
- Важно, что внешние ссылки на переменную func будут использовать эту анонимную функцию, но внутри функции нельзя обратиться к ней через имя (так как имя отсутствует).
```js
const func = function () {
  // Невозможно обратиться к самой функции через имя
  console.log("Hello from the anonymous function");
};

func();  // Работает, вызовем функцию через переменную
```

2. Именованная функция (Function Expression)
```js
const func = function func() { }
```
- В этом случае функция имеет имя (в данном случае func).
- Функция также присваивается переменной func, но имя func доступно внутри самой функции.
- Имя функции в этом случае не будет доступно за пределами функции, так как это Function Expression, и оно не становится свойством переменной func.
```js
const func = function func() {
  console.log("Hello from the named function");
};

func();  // Работает, вызовем функцию через переменную

// Ошибка: нельзя вызвать функцию через ее имя из внешней области видимости
// func();  // Error: func is not defined
```

### Разница в области видимости имени функции:
1. В анонимной функции имя функции (если бы оно было задано) вообще не существует. Вы не можете обратиться к ней внутри функции по имени, потому что имя привязано только к переменной.
2. В именованной функции имя доступно внутри самой функции, но не доступно в внешней области видимости. Это может быть полезно, например, для рекурсии, когда функция вызывает саму себя по имени.

Пример с рекурсией:
```js
const func = function func() {
  console.log("Calling function...");
  func();  // Здесь мы вызываем функцию по ее имени
};

func();  // Начнем выполнение
```
В случае анонимной функции, рекурсия не сработала бы, так как в теле функции нет имени для обращения к самой себе.

## Arrow Functions
Arrow Functions - сокращённый синтаксис для объявления функций.
```js
// Обычная функция
function add(a, b) {
  return a + b;
}

// Arrow Function
const add = (a, b) => a + b;
```
- Не имеют собственного контекста this
- Отсутствие arguments
Если вам нужно использовать arguments в стрелочной функции, можно использовать rest-оператор
- Нет new (Нельзя использовать как конструктор)
```js
const MyClass = () => {};
const obj = new MyClass();  // Ошибка: MyClass is not a constructor
```


## Как передаются аргументы:
1. Простые типы (передача по значению):
- Когда мы передаем примитивные значения (например, числа, строки, булевы значения), эти значения передаются по значению.
- Это означает, что в функцию передается копия значения, и изменение параметра внутри функции не влияет на оригинальное значение.
```js
function modifyValue(num) {
  num = num + 10;
  console.log(num); // 20
}

let x = 10;
modifyValue(x);
console.log(x); // 10 (оригинальное значение x не изменилось)
```

2. Объекты и массивы (передача по ссылке):
- Когда мы передаем объекты или массивы, они передаются по ссылке. Это означает, что внутри функции параметр будет указывать на тот же объект/массив, что и переданный аргумент. Если внутри функции мы изменим содержимое объекта или массива, эти изменения отразятся на оригинале.
Пример с объектом:
```js
function modifyObject(obj) {
  obj.name = "Igor";
}

let person = { name: "John" };
modifyObject(person);
console.log(person.name); // Igor (объект был изменен)
```
Пример с массивом:
```js
function modifyArray(arr) {
  arr.push(100);
}

let numbers = [1, 2, 3];
modifyArray(numbers);
console.log(numbers); // [1, 2, 3, 100] (массив был изменен)
```

### Резюме:
- `Примитивы (строки, числа, булевы значения и т. д.)` передаются по значению. Когда вы передаете примитив, внутри функции создается его копия, и изменения в параметре не затронут оригинал.
- `Объекты и массивы` передаются по ссылке. Когда вы передаете объект или массив, внутри функции параметр будет указывать на тот же объект или массив, что и переданный аргумент, и изменения внутри функции отразятся на оригинале.

## Параметры
1. Параметры без значений по умолчанию:
Когда в функции объявлены параметры без значений по умолчанию, если вы не передадите все аргументы при вызове функции, то недостающие параметры будут иметь значение `undefined`.
```js
function getName(a, b, c, d) {
  console.log(a, b, c, d);
}

getName(1, 2, 3);  // 1 2 3 undefined
```

2. Параметры со значениями по умолчанию:
Параметры с значениями по умолчанию обычно ставят в конец списка параметров, чтобы избежать путаницы с передачей аргументов.
```js
function getName(a, b, c = 5, d = 10) {
  console.log(a, b, c, d);
}

getName(1, 2);  // 1 2 5 10
```

3. Использование arguments:
В функции можно использовать объект arguments, который является массивоподобным объектом, содержащим все переданные аргументы, независимо от того, сколько их было передано:
```js
function getName(a, b) {
  console.log(arguments);  // { 0: 1, 1: 2 }
}

getName(1, 2);
```
`arguments` позволяет обращаться ко всем переданным аргументам, даже если их меньше, чем параметров в функции.

### Резюме:
- Нет ошибки, если вы не передали все аргументы, но недостающие параметры будут иметь значение undefined, если не указано значение по умолчанию.
- Параметры по умолчанию можно ставить в конец списка параметров, чтобы избежать путаницы.
- Для работы с аргументами, которые не передаются, можно использовать объект arguments или явно задавать значения по умолчанию.


## this
Контекст — это то, к чему относится или на что указывает ключевое слово `this` в конкретный момент выполнения кода.

1. Function Declaration (Обычные функции)
Контекст this в обычных функциях: 
- В глобальном контексте (не в объекте или классе): в строгом режиме (`'use strict'`) `this` будет `undefined`. В обычном режиме `this` будет указывать на глобальный объект, который в браузере — это `window`.
```js
function regularFunction() {
  console.log(this);  // в обычном режиме: window (глобальный объект)
}
regularFunction();
```

- Когда функция вызвана как метод объекта, this будет указывать на этот объект:
```js
const obj = {
  name: 'Alice',
  greet: function() {
    console.log(this.name);  // this будет указывать на obj
  }
};

obj.greet();  // Output: Alice
```

- Когда функция вызвана через `call`, `apply` или `bind`, this можно явно установить на любой объект:
```js
function greet() {
  console.log(this.name);
}

const person = { name: 'Bob' };
greet.call(person);  // Output: Bob
```

2. Function Expression (Функции-выражения)
Function Expression может использовать new, но только в случае, если это обычная (не стрелочная) функция, которая является конструкцией для создания объектов.

Контекст this в функциях-выражениях:
- Если функция-выражение вызвана в глобальном контексте, то значение `this` в нестрогом режиме будет указывать на глобальный объект (в браузере — на `window`), а в строгом режиме (`'use strict'`) будет `undefined`.
```js
const greet = function() {
  console.log(this);  // В нестрогом режиме: window (глобальный объект)
};

greet();
```

- Если функция-выражение вызывается как метод объекта, `this` будет указывать на этот объект:
```js
const obj = {
  name: 'Charlie',
  greet: function() {
    console.log(this.name);  // this будет указывать на obj
  }
};

obj.greet();  // Output: Charlie
```

- При вызове через `call`, `apply`, или `bind` значение `this` можно задать вручную:
```js
const greet = function() {
  console.log(this.name);
};

const person = { name: 'Dave' };
greet.call(person);  // Output: Dave
```

## Что такое apply, call и bind?
Эти методы позволяют явным образом указать, какой объект должен быть привязан к this в функции. Они позволяют изменять контекст вызова функции, независимо от того, как эта функция была вызвана (например, как метод объекта или как обычная функция).
1. `call`
Метод call вызывает функцию с заданным значением this и переданными аргументами, которые передаются по отдельности.
```js
function greet() {
  console.log(`Hello, ${this.name}`);
}

const person = { name: 'Alice' };

greet.call(person);  // Выведет: "Hello, Alice"
```
В данном примере this в функции greet будет ссылаться на объект person, благодаря методу call.

2. `apply`
Метод apply аналогичен call, но принимает аргументы в виде массива (или массива аргументов), а не через запятую.
```js
function greet(greeting) {
  console.log(`${greeting}, ${this.name}`);
}

const person = { name: 'Bob' };

greet.apply(person, ['Hello']);  // Выведет: "Hello, Bob"
```
Здесь this снова будет ссылаться на объект person, и apply передает аргументы функции как массив.

3. `bind`
Метод bind не вызывает функцию немедленно, а возвращает новую функцию, привязанную к определенному контексту. Вызываемая функция будет использовать заданный контекст this при её вызове.
```js
function greet() {
  console.log(`Hello, ${this.name}`);
}

const person = { name: 'Charlie' };

const boundGreet = greet.bind(person);
boundGreet();  // Выведет: "Hello, Charlie"
```
Здесь bind создает новую функцию boundGreet, которая всегда будет использовать this, ссылающийся на объект person, когда её вызовут.

### Резюме:
- В Function Declaration и Function Expression можно изменять контекст this с помощью методов apply, call и bind.
- Стрелочные функции не позволяют изменять this с помощью этих методов, так как this в них наследуется от внешнего контекста.



3. Arrow Functions (Стрелочные функции)
Стрелочные функции (Arrow Functions) в JavaScript — это особый тип функций, введённый в ES6. Они имеют несколько ключевых отличий и особенностей по сравнению с Function Declaration и Function Expression.

Основные особенности стрелочных функций:
1. Синтаксис: Стрелочные функции имеют более компактный синтаксис, который убирает необходимость в использовании ключевого слова function и фигурных скобок (если тело функции состоит из одного выражения).
```js
const greet = (name) => `Hello, ${name}!`;
```

2. this в стрелочных функциях: Важнейшая особенность стрелочных функций — это то, что они не имеют своего this. Вместо этого, this в стрелочной функции будет наследоваться от окружающего контекста, в котором эта функция была определена.

Это отличается от обычных функций, где this зависит от того, как была вызвана функция (через объект или как обычная функция).

Пример:
```js
const person = {
  name: 'Alice',
  greet: function() {
    console.log(this.name);  // `this` указывает на объект person
  }
};

person.greet();  // Выведет: "Alice"
```
Для стрелочных функций this будет указывать на окружающий контекст, а не на объект, через который была вызвана функция:
```js
const person = {
  name: 'Alice',
  greet: () => {
    console.log(this.name);  // `this` не указывает на объект person
  }
};

person.greet();  // Выведет: undefined (если в глобальном контексте)
```

В стрелочных функциях this всегда ссылается на контекст, в котором эта функция была определена, а не на объект, который её вызывает.

3. Отсутствие arguments
4. Невозможность использовать с new: Стрелочные функции не могут быть использованы как конструкторы, так как они не имеют своего this и не могут быть вызваны с помощью new.

Arrow Function: Это компактная форма записи для Function Expression, где нет ключевого слова function, а используется =>. Стрелочные функции всегда являются анонимными (это значит, что стрелочная функция не имеет имени, в отличие от обычной функции, которая может быть названа при её объявлении).


##  Асинхронные функции (Async Functions)
- Асинхронные функции всегда возвращают промис, независимо от того, что они возвращают внутри (обычное значение или промис).
- Ключевое слово await позволяет "приостановить" выполнение функции до получения значения из промиса, что облегчает работу с асинхронным кодом.

## Immediately Invoked Function Expressions (IIFE)
Это функции, которые выполняются сразу после своего объявления. Они используются для создания замкнутых областей видимости (например, для изоляции переменных).

## Тонкости работы с функциями:
1. Hoisting:
- Функции, объявленные через function, поднимаются в начало их области видимости (функции можно вызывать до их объявления).
- Функции, определенные как выражения (например, через const или let), не поднимаются.

2. this в функциях:
- В обычных функциях this зависит от того, как была вызвана функция (например, в глобальной области или как метод объекта).
- В стрелочных функциях this привязывается к контексту, в котором функция была объявлена, и не изменяется.

3. Возврат значений:
- Функции могут возвращать любые типы данных, включая объекты, массивы, функции или промисы.
- Важно помнить, что если функция не возвращает явным образом значение, она по умолчанию возвращает undefined.

4. Передача параметров:
- В JavaScript функции могут принимать любое количество аргументов, но если передать меньше, чем ожидается, недостающие параметры будут равны undefined.
- Кроме того, в функцию можно передать любые типы данных, включая функции и объекты.
