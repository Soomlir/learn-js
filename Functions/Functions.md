# Функции
## Function Declaration - Это значит, что код с ними можно вызывать до их объявления.
## Function Expressions - Не поднимаются (не hoisting). Вы можете вызывать такие функции только после их объявления, иначе получите ошибку.

## Arrow Functions - Нет собственного контекста this. Внутри стрелочных функций this будет указывать на контекст, в котором эта функция была определена.

## Функции-конструкторы (Constructor Functions)
Эти функции используются для создания объектов с помощью оператора new. Они используются в старом синтаксисе для создания "классов", до появления классов в ES6.
```js
function Person(name, age) {
  this.name = name;
  this.age = age;
}

const person = new Person('Alice', 30);
console.log(person.name);  // Output: Alice
```

##  Асинхронные функции (Async Functions)
- Асинхронные функции всегда возвращают промис, независимо от того, что они возвращают внутри (обычное значение или промис).
- Ключевое слово await позволяет "приостановить" выполнение функции до получения значения из промиса, что облегчает работу с асинхронным кодом.

## Immediately Invoked Function Expressions (IIFE)
Это функции, которые выполняются сразу после своего объявления. Они используются для создания замкнутых областей видимости (например, для изоляции переменных).

## this
В JavaScript ключевое слово this имеет важное значение для контекста, в котором вызывается функция. Поведение this зависит от того, как и где была вызвана функция. Рассмотрим, как работает this в разных типах функций: Function Declaration, Function Expression и Arrow Function.

1. Function Declaration (Обычные функции)
Когда используется обычная функция, значение this зависит от того, как эта функция была вызвана.
```js
function regularFunction() {
  console.log(this);
}

regularFunction();  // В браузере: this будет указывать на глобальный объект (window)
```

Контекст this в обычных функциях: 
- В глобальном контексте (не в объекте или классе): в строгом режиме (`'use strict'`) `this` будет `undefined`. В обычном режиме `this` будет указывать на глобальный объект, который в браузере — это `window`.
```js
function regularFunction() {
  console.log(this);  // в обычном режиме: window (глобальный объект)
}
regularFunction();
```

- Когда функция вызвана как метод объекта, this будет указывать на этот объект:
```js
const obj = {
  name: 'Alice',
  greet: function() {
    console.log(this.name);  // this будет указывать на obj
  }
};

obj.greet();  // Output: Alice
```

- Когда функция вызвана через `call`, `apply` или `bind`, this можно явно установить на любой объект:
```js
function greet() {
  console.log(this.name);
}

const person = { name: 'Bob' };
greet.call(person);  // Output: Bob
```

2. Function Expression (Функции-выражения)
В функциях, созданных с помощью выражений (например, анонимные функции или именованные функции), this также зависит от контекста, в котором функция вызывается.
```js
const greet = function() {
  console.log(this);
};

greet();  // В глобальном контексте (в браузере): this будет указывать на window
```

Контекст this в функциях-выражениях:
- Если функция-выражение вызвана в глобальном контексте, то значение `this` в нестрогом режиме будет указывать на глобальный объект (в браузере — на `window`), а в строгом режиме (`'use strict'`) будет `undefined`.
```js
const greet = function() {
  console.log(this);  // В нестрогом режиме: window (глобальный объект)
};

greet();
```

- Если функция-выражение вызывается как метод объекта, `this` будет указывать на этот объект:
```js
const obj = {
  name: 'Charlie',
  greet: function() {
    console.log(this.name);  // this будет указывать на obj
  }
};

obj.greet();  // Output: Charlie
```

- При вызове через `call`, `apply`, или `bind` значение `this` можно задать вручную:
```js
const greet = function() {
  console.log(this.name);
};

const person = { name: 'Dave' };
greet.call(person);  // Output: Dave
```

3. Arrow Functions (Стрелочные функции)
Стрелочные функции ведут себя по-другому. В отличие от обычных функций, стрелочные функции не имеют собственного контекста `this`. Они "позаимствуют" значение `this` из внешнего контекста, где эта функция была определена.
```js
const greet = () => {
  console.log(this);
};

greet();  // В браузере this будет указывать на window (или на global в Node.js)
```

Контекст this в стрелочных функциях:
- Стрелочные функции не имеют собственного `this`. Они наследуют значение this из окружающего контекста (лексического контекста), в котором они были определены. То есть стрелочные функции не привязывают this к моменту их вызова.

Например:
```js
const obj = {
  name: 'Eve',
  greet: function() {
    const inner = () => {
      console.log(this.name);  // this унаследовано от greet()
    };
    inner();
  }
};

obj.greet();  // Output: Eve
```

- В этом примере стрелочная функция `inner` использует `this` из контекста функции `greet`, а не из контекста её собственного вызова, что отличается от поведения обычных функций.

- Внутри стрелочных функций this не изменяется, даже если они вызываются как методы объекта, через `call`, `apply` или `bind`.
```js
const obj = {
  name: 'Frank',
  greet: () => {
    console.log(this.name);  // this указывает на глобальный объект (window или global)
  }
};

obj.greet();  // Output: undefined (если в строгом режиме)
```

В этом случае `this` внутри стрелочной функции будет указывать на глобальный объект, потому что стрелочная функция не имеет своего контекста, и заимствует его от окружающего контекста.

### Резюме:
- Обычные функции и функции-выражения имеют свой контекст `this`, который зависит от способа вызова функции. Если функция вызывается как метод объекта, то `this` будет ссылаться на этот объект. В глобальном контексте или при вызове через `call`, `apply`, или `bind` значение `this` можно контролировать.
- Стрелочные функции не имеют собственного контекста this и всегда берут его из внешнего контекста, в котором они были определены.



## Тонкости работы с функциями:
1. Hoisting:
- Функции, объявленные через function, поднимаются в начало их области видимости (функции можно вызывать до их объявления).
- Функции, определенные как выражения (например, через const или let), не поднимаются.

2. this в функциях:
- В обычных функциях this зависит от того, как была вызвана функция (например, в глобальной области или как метод объекта).
- В стрелочных функциях this привязывается к контексту, в котором функция была объявлена, и не изменяется.

3. Возврат значений:
- Функции могут возвращать любые типы данных, включая объекты, массивы, функции или промисы.
- Важно помнить, что если функция не возвращает явным образом значение, она по умолчанию возвращает undefined.

4. Передача параметров:
- В JavaScript функции могут принимать любое количество аргументов, но если передать меньше, чем ожидается, недостающие параметры будут равны undefined.
- Кроме того, в функцию можно передать любые типы данных, включая функции и объекты.

