# Vue
Во Vue используется декларативный подход и компонентную модель программирования.
Декларативный подход - что сделать, Импративный подход - как сделать.

Декларативная отрисовка: декларативно описывает финальный HTML на основе состояния JS

Реактивность: Vue автоматически отслеживает изменения состояния JavaScript и эффективно обновляет DOM, когда происходят изменения.

SFC - файлы с расширением .vue 
script - логика компонента
template - шаблон компонента
style - стили компонента

При использовании Options API логика компонентов определяется с помощью объекта опций, таких как data, methods и mounted.
С помощью Composition API мы определяем логику компонента, используя импортированные функции API. 


# ОСНОВЫ

В createApp(корневой компонент - App.vue).mount(айди div)

Директивы — специальные атрибуты с префиксом v-

В значении директивы ожидается одно выражение JavaScript (за исключением v-for, v-on и v-slot, о которых поговорим далее). 
Задачей директивы является реактивное применение изменений к DOM, когда изменится значение выражения. 

Наиболее простой способ связывания данных — текстовая интерполяция с использованием «Mustache»-синтаксиса из двойных фигурных скобок


# СИНТАКСИС ШАБЛОНОВ

Vue компилирует шаблоны в хорошо оптимизированный код JavaScript.

v-bind
 Если связанное значение будет null или undefined, то атрибут будет удален из отрисованного элемента.
v-bind: === :
```html
<!-- так же, как :id="id" -->
<div :id></div>

<!-- это также работает -->
<div v-bind:id></div>


<button :disabled="isButtonDisabled">Кнопка</button>
```
Атрибут disabled будет добавляться, когда значение isButtonDisabled истинно. Он также будет добавляться,
 если значением будет пустая строка, для сохранения консистентности с `<button disabled="">`. 
При использовании других ложных значений атрибут будет опущен.


В шаблонах Vue выражения JavaScript можно использовать в следующих ситуациях:

    Внутри текстовых интерполяций (двойных фигурных скобок)
    В значении атрибутов директив Vue (специальные атрибуты, именуемые с v-

v-on:click= 
@click=

Модификаторы — специальные постфиксы, отделяемые точкой, которые обозначают, что директива должна быть привязана каким-то особенным образом. 


# ОСНОВЫ РЕАКТИВНОСТИ

ref, который оборачивает внутреннее значение в специальный объект
const count = ref(0)
console.log(count) // { value: 0 }
console.log(count.value) // 0


Нам не нужно добавлять .value при использовании ссылки в шаблоне. 
Для удобства ref автоматически "разворачиваются" при использовании внутри шаблонов 
Вы также можете мутировать ref непосредственно в обработчиках событий

Когда вы изменяете реактивное состояние, DOM обновляется автоматически. 

reactive() делает сам объект реактивным

`setup` это специальный хук, предназначенный для Сomposition API.
Под капотом Vue выполняет отслеживание в геттере, а срабатывание - в сеттере.


## ВЫЧИСЛЯЕМЫЕ СВОЙСТВА
шаблон должен быть простым и декларативным
для сложной логики, включающей реактивные данные, следует использовать вычисляемые свойства.
Вычисляемые свойства по умолчанию состоят только из геттера.


## РАБОТА С КЛАССАМИ И СТИЛЯМИ
выражения могут принимать массивы или объекты.


## УСЛОВНАЯ ОТРИСОВКА

v-if
```html
<h1 v-if="awesome">Vue восхитителен!</h1>
```
h1 отображается только, если awesome == true
v-else
Элемент с директивой v-else должен следовать сразу за элементом с директивой v-if или v-else-if — иначе он не будет распознан.
v-else-if
Как и v-else, v-else-if должен следовать сразу за элементом с v-if или v-else-if.

Поскольку v-if является директивой, то она должна быть указана на одном элементе
можно использовать тег template для группировки
Директивы v-else и v-else-if также можно использовать на `<template>`.

v-show
Отличия в том, что элемент с v-show будет всегда отрисовываться и оставаться в DOM, а переключаться будет лишь его CSS свойство display.
v-show нельзя использовать на элементе `<template>` и она не работает с v-else.

v-if с внутренними элементами отрисовывается только, если аргумент true
v-show - всегда отрисовывается в DOM 

В целом, у v-if выше затраты на переключение, в то время как v-show имеет больше затрат на первичную отрисовку. 
Так что используйте v-show, если переключения будут частыми, и предпочитайте v-if, если условие может и не измениться во время исполнения.


## ОТРИСОВКА СПИСКОВ
```html
<li v-for="(item, index) in items">
```
item - элемент массива
index - индекс текущего элемента
in, of 
Привязка key ожидает использования примитивных значений — строк и чисел.


К таким мутирующим методам относятся:
    push()
    pop()
    shift()
    unshift()
    splice()
    sort()
    reverse()

Но есть и другие, например filter(), concat() и slice(), которые не мутируют исходный массив, а всегда возвращают новый массив.


## ОБРАБОТКА СОБЫТИЙ

Значение обработчика может быть одним из следующих:

    Обработчик события в виде инлайн-кода: Код JavaScript будет выполняться при срабатывании события (аналогично как в нативном атрибуте onclick).

    Обработчик события в виде метода: Имя свойства или путь, указывающий на метод, объявленный в компоненте.


## ОСНОВЫ КОМПОНЕНТОВ

Передача входных параметров 
Входные параметры — это настраиваемые атрибуты, которые вы можете зарегистрировать в компоненте. используя макрос defineProps
defineProps(['title'])
defineProps макрос компилятора используемый только внутри `<script setup>` и не нуждается в явном импорте

Прослушивание событий 
экземпляры компонента предоставляют собственную систему событий
Родительский компонент может прослушивать любые события на экземпляре дочернего компонента
с помощью v-on или @, аналогично отслеживанию нативных событий DOM

```vue
<BlogPost
  ...
  @enlarge-text="postFontSize += 0.1"
 />
```

Тогда дочерний компонент может сгенерировать событие с помощью встроенного метода $emit, передавая ему имя события

<!-- BlogPost.vue, не добавлен <script> -->
<template>
  <div class="blog-post">
    <h4>{{ title }}</h4>
    <button @click="$emit('enlarge-text')">Увеличить размер текста</button>
  </div>
</template>

Все генерируемые компонентом события можно перечислить в defineEmits

Как и defineProps, defineEmits используется только в <script setup> и не требует импорта.

defineEmits возвращает функцию emit, которая эквивалентна методу $emit

1. Входные параметры ?
2. События компонентов ?
3. v-model ?
4. Передача обычных атрибутов ?
