# try...catch

Позволяет обработать ситуацию, когда код выбрасывает ошибку, и не сломать приложение

С пойманной в catch ошибкой можно поступить как угодно: отправить данные в специальный логгер, обработать данные из неё и даже выбросить новую ошибку, которая может быть поймана в другом месте и т.д.

Если в блоке try не произошло ошибок, то код в блоке catch не выполнится.

В случае ошибки выполнение в блоке try прерывается и сразу же переходит в блок catch . После него скрипт продолжит своё выполнение, как и прежде.

Если в catch ошибка, то дальнейший код не выполнится

В конструкцию try...catch можно добавить блок finally, который выполнится после блоков try и catch. Неважно какой код выполнился в предыдущих блоках, после их завершения (даже если из catch была выброшена новая ошибка) исполнится код в блоке finally.
```js
try {
  webSocket.connect('ws://....')

  callMayThrowError()
} catch (err) {
  // Здесь тоже может возникнуть ошибка
  doSomeWithError(err)
} finally {
  // Выполнится всегда
  webSocket.disconnect('ws://....')
}
```

Наличие блока finally необязательно. finally можно использовать и без блока catch.
```js
try {
  // Отправить данные на сервер, здесь нам неважна обработка ошибки
  sendData()
} finally {
  // Закрыть соединение при любом результате
  closeConnection()
}
```

Конструкция try...catch работает только синхронно. Таким образом, с помощью try...catch нельзя обработать ошибку, которая возникла в асинхронном коде.

Однако, если записать асинхронный код в синхронном стиле с помощью async/await, то в этом случае обработку ошибок можно осуществлять с помощью try...catch
```js
async function handlePromise() {
  try {
    // Промис вернется с ошибкой
    await Promise.reject('err')
  } catch (e) {
    // Теперь ошибка будет поймана
    console.log('Ошибка', e) // err
  }
}

handlePromise()
```

Чтобы поймать ошибку из setTimeout(), блоки try...catch должны находиться внутри функции

Любой асинхронный код можно переписать в синхронном стиле через async/await, чтобы использовать единый стиль обработки ошибок, используя try...catch

1. SyntaxError - синтаксическая ошибка
2. ReferenceError - ошибка обращения (ссылки)
3. TypeError - ошибка типа
4. RangeError - ошибка диапазона
5. URIError - ошибка URI
6. EvalError - ошибка выполнения
7. InternalError - внутренняя ошибка

# try catch
В JavaScript конструкция try...catch используется для обработки ошибок в коде. Это позволяет избежать остановки работы программы в случае возникновения исключений (ошибок) и позволяет на них реагировать.

1. Синтаксис `try...catch`
```js
try {
    // Код, который может вызвать ошибку
} catch (error) {
    // Код для обработки ошибки
}
```

* `try`: В блоке `try` размещается код, который может вызвать ошибку (например, деление на ноль, вызов метода у `null` или `undefined`, синтаксическая ошибка и т. д.).
* `catch`: В блоке `catch` размещается код для обработки ошибок, которые могут возникнуть в блоке `try`. Параметр `error` (или любое другое имя) — это объект ошибки, который может содержать информацию о произошедшей ошибке.

2. Как пробрасывать ошибки из `catch` дальше
Когда ошибка обрабатывается в `catch`, вы можете либо исправить ошибку, либо пробросить её дальше, чтобы она была обработана на более высоком уровне. Для этого используется оператор `throw`.
```js
function processData(data) {
    try {
        if (!data) {
            throw new Error("Data is required");
        }
        // Код для обработки данных
        console.log(data);
    } catch (error) {
        console.log("Caught an error:", error.message);
        // Пробрасываем ошибку дальше
        throw error;
    }
}

try {
    processData(null); // Параметр null вызовет ошибку
} catch (error) {
    console.log("Error caught in main:", error.message);
}
```

В данном примере:
- В функции `processData` ошибка выбрасывается с помощью throw new Error(...)
- Эта ошибка перехватывается в блоке `catch` и затем пробрасывается снова через `throw error;`, чтобы её можно было обработать в более внешнем блоке `catch`.

3. Что такое `new Error` и как с этим работать
`new Error()` — это встроенный конструктор в JavaScript для создания объектов ошибок. Он создаёт объект ошибки с сообщением и стеком вызовов.
```js
let error = new Error("Something went wrong!");
console.log(error.message); // "Something went wrong!"
console.log(error.stack); // Стек вызовов
```

Объект ошибки (`Error`) имеет следующие свойства:
- `message` — строка, содержащая описание ошибки.
- `stack` — строка, содержащая стек вызовов, который помогает отследить, где ошибка произошла.

Вы можете создать свою собственную ошибку, наследуя от `Error`, если хотите добавлять дополнительные свойства или методы:
```js
class CustomError extends Error {
    constructor(message, code) {
        super(message);
        this.name = "CustomError"; // Устанавливаем имя ошибки
        this.code = code; // Дополнительное свойство
    }
}

try {
    throw new CustomError("Something custom went wrong", 123);
} catch (error) {
    console.log(error.name); // CustomError
    console.log(error.message); // Something custom went wrong
    console.log(error.code); // 123
}
```

4. Резюме
- `try...catch` помогает перехватывать и обрабатывать ошибки.
- `throw` позволяет выбрасывать ошибки, которые могут быть обработаны в другом месте.
- `new Error()` создаёт объекты ошибок с сообщением и стеком вызовов.
- Вы можете создавать собственные ошибки, наследуя от `Error`, чтобы добавлять дополнительные данные или логику.
