// Очень многое в JavaScript является объектами

// Если объект как значение свойства объекта - называется вложенным объектом

// Массив - объект
// Функция - объект
// Число - объект
// Строка - объект
// Строки и числа только ведут себя как объекты

// Интерпритатор может возвращать undefined (в консоли) - значение, которое возвращает выражение

// console.dir() - отображает все свойства объекта
// console.table() - отображает все свойства объекта в табличном виде

// Выражение возвращает значение
// Присовение тоже выражение

// Результатом каждого выражения является - значение


// Pascal case - для типов и классов
// Constant case - для констант
// Camel case - для всех других переменных

// JavaScript - динамически типизируемый язык

// function a() {}   a = 10; a(); - Ошибка

// Порядок свойств объекта не имеет значение
// const country = 'country'
// myCity[country] = 'USA';
// В [] - можно использовать любое выражение JS

// Вложенные свойства объектов (объект как значение свойство родительского объекта)
// В качестве значений свойств можно использовать любые выражения, которые присвоятся свойству

const name = 'Igor';
const postQty = 30;

// Сокращенный формат записи свойств
const person = {
  name, // тоже самое, что и name: name
  postQty,
  isProgrammer: true,
  cityGreeting() { // - сокращенный формат записи методов. Если значение свойства функция - можно ставить () без function

  },
  city: function() {

  }
};
// Сокращенные свойства рекомендуется размещать в начале объекта




// JSON
// JSON.parse() - распарсить json пришедший от сервера и получим JavaScript объект
// JSON.stringify() - получить из объекта js строку json

// const person2 = Object.assign({}, person); - создаем новый объект с помощью assign
// person2 - новый объект, person - другой объект
// При создании новых объектов, ссылки на вложенные объекты сохраняются
// и мы можем частично менять исходных объект


// const person2 = {...person} - копирование с помощью spread 
// так же вложенные объекты можно изменять оригинального объекта


// assign, spread - подходит, когда нет вложенных объектов в объекте


// const person3 = JSON.parse(JSON.stringify(person)) - полностью новый объект
// ссылки на вложенные объекты не сохраняются



// Функция - объект

// Функция может быть:
// Именнованой
// Присвоена переменной
// Анонимной
// Аргументом при вызове другой функции
// Значением свойства (метода) объекта

// Тело функции - то что в скобках
// Если нет return - функция возвращает undefined
// function num() {} - объявление функции - создается новая переменная num
// Внутри функции не рекомендуется менять внешние объекты

/// Callback function вызывается внутри другой функции

// Правила работы с функциями
// 1. Называть функции исходя из выполнения задач
// 2. Одна функция должна выполнять одну задачу
// 3. Не рекомендуется изменять внешние относительно функции переменные

// Pure function - работает со своими переменными, не меняет внешние (даже те, которые переданы аргументами)


// Область видимости - определяет границы действия переменной
// Для каждого вызова функции создаются новые области видимости


// Правила работы с переменными
// 1. Все переменные объявлять перед их использованием
// 2. Стараться использовать const везде, где это возможно
// 3. Внутри функций не изменять переменные с внешних областей видимости


// Типы областей видимости
// 1. Глобальная область видимости
// 2. Область видимости функций
// 3. Область видимости блока
//    Переменные объявленные с помощью let или const внутри блока
// имеют область видимости, ограниченную этим блоком

// Переменная а нигде не объявлена
function myFn() { // переменная а будет автоматически объявлена в глобальной области видимости
  a = true;
  console.log(a);
}
// 'use strict' - запрещает использование необъявленных переменных



// Оператор - встроенная функция
// 1. Арифметические + - / *
// 2. Сравнения === !== <= >=
// 3. Логические ! && ||
// 4. Присваивания =

// Текстовые операторы - typeof instanceof new delete
// Оператор запятая ,

// Унарные операторы . У унарных операндов всегда один операнд (аргумент)
a++;
+a;
delete obj.a;
typeof a;
new Object();

// Бинарные операторы . У бинарных операторов два операнда (аргумента)
a = 5;
a + b;
a += 5;
a === b;
a && b;

// Инфиксный формат (инфиксная запись) - оператор находится между двумя операндами
a = true;
a + b;
a += 5;
a || b;
a > b;

// Префиксная запись (сначала оператор, потом операнд)
++a;
delete obj.a;
typeof a;

// Постфиксная запись (сначала операнд, после оператор)
a++;
myFunction(); // () - говорят, вызвать определенную функцию

// Приоритет операторов

// false значения Booleadn(value) 
false
0
''
undefined
null

// typeof 10 === 'number' // true


// Выражение 1 && Выражение 2 - оператор короткого замыкания - мы ищем 1 ложное значение
// Выражение 1 || Выражение 2 - если 1 тру, то до второго не доходит - оператор короткого замыкания
// Всегда возвращают значение одного из операнда


// Оператор разделения объекта на свойства ... 
const button = {
  width: 400,
  text: 'Buy',
  color: 'green',
};

const redButton = {
  ...button, // использовать в начале, чтобы перезаписывать свойства объекта 
  color: 'red'
};

const btn = {
  ...btnInfo,
  ...btnStyle,
};


// Функциональное выражение - отсутствует имя функции
// Функциональные выражения всегда анонимны

// Значения по умолчанию вычисляются в момент вызова функции



// Обработка ошибок 
// throw new Error('error');

// Ловить ошибки, чтобы продолжалось выполнение кода
try {

} catch (error) {

}



// Инструкции

// Выражение (всегда возвращает значение)
// Инструкция (выполняет действия) - if ifelse for 
// Выражение-инструкция 

// Инструкция обычно заканчивается точкой с запятой. Исключение: точка с запятой не требуется после блока инструкций

// Выражения могут быть использованы как аргументы в вызовах функций



// Условные конструкции
// if 
// if else 
// if else if
// switch
// тернарный оператор

// две ветки if else не могут быть выполнены две сразу

// if else ветки выполняются один раз


// Типы циклов 
// for 
// for in
// for of 
// while
// do while


// Модули
// Модули - позволяют структурировать код
// Модули позволяют избегать дублирования блоков кода




// Классы
// Переменная this указывает на экземпляр класса
// instanceof - оператор - является ли экземпляром родителя

firtsComment instanceof Comment // true
firstComment instanceof Object // true

firstComment.hasOwnProperty('text'); // true
// проверка принадлежности свойства экземпляру класса

// метод static - не наследуется экземплярами класса
// но доступны как методы класса


// Промисы
// Промисы позволяют обрабатывать отложенные во времени события
// Промис - это обещание предоставить результат позже


// Async / Await - специальный синтаксис для упрощения работы с промисами

// async функция - всегда возвращает промис

async function fn () { }
const fn = async () => { }


// Главное в Async/Await
// 1. Async/Await - это синтаксическая надстройка над промисами
// 2. await синтаксис возможен только внутри async функций
// 3. async функция всегда возвращает Promise
// 4. async функция ожидает результата инструкции await и не выполняет последующие инструкции
